{"id":"node_modules/@giphy/js-fetch-api/dist/request.js","dependencies":[{"name":"D:\\testhub\\node_modules\\@giphy\\js-fetch-api\\dist\\request.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\testhub\\node_modules\\@giphy\\js-fetch-api\\src\\request.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\testhub\\package.json","includedInParent":true,"mtime":1633782651602},{"name":"D:\\testhub\\node_modules\\@giphy\\js-fetch-api\\package.json","includedInParent":true,"mtime":1633781127523},{"name":"./constants","loc":{"line":43,"column":26},"parent":"D:\\testhub\\node_modules\\@giphy\\js-fetch-api\\dist\\request.js","resolved":"D:\\testhub\\node_modules\\@giphy\\js-fetch-api\\dist\\constants.js"},{"name":"./fetch-error","loc":{"line":44,"column":44},"parent":"D:\\testhub\\node_modules\\@giphy\\js-fetch-api\\dist\\request.js","resolved":"D:\\testhub\\node_modules\\@giphy\\js-fetch-api\\dist\\fetch-error.js"}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DEFAULT_ERROR = exports.ERROR_PREFIX = void 0;\nvar constants_1 = require(\"./constants\");\nvar fetch_error_1 = __importDefault(require(\"./fetch-error\"));\nexports.ERROR_PREFIX = \"@giphy/js-fetch-api: \";\nexports.DEFAULT_ERROR = 'Error fetching';\nvar identity = function (i) { return i; };\nvar requestMap = {};\nvar maxLife = 60000; // clear memory cache every minute\nvar errorMaxLife = 6000; // clear error memory cache after a second\nvar purgeCache = function () {\n    var now = Date.now();\n    Object.keys(requestMap).forEach(function (key) {\n        var ttl = requestMap[key].isError ? errorMaxLife : maxLife;\n        if (now - requestMap[key].ts >= ttl) {\n            delete requestMap[key];\n        }\n    });\n};\nfunction request(url, normalizer, noCache) {\n    var _this = this;\n    if (normalizer === void 0) { normalizer = identity; }\n    if (noCache === void 0) { noCache = false; }\n    purgeCache();\n    if (!requestMap[url] || noCache) {\n        var makeRequest = function () { return __awaiter(_this, void 0, void 0, function () {\n            var fetchError, response, result, message, result, _1, unexpectedError_1;\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _b.trys.push([0, 9, , 10]);\n                        return [4 /*yield*/, fetch(\"\" + constants_1.serverUrl + url, {\n                                method: 'get',\n                            })];\n                    case 1:\n                        response = _b.sent();\n                        if (!response.ok) return [3 /*break*/, 3];\n                        return [4 /*yield*/, response.json()];\n                    case 2:\n                        result = (_b.sent());\n                        // no response id is an indiication of a synthetic response\n                        if (!((_a = result.meta) === null || _a === void 0 ? void 0 : _a.response_id)) {\n                            throw { message: \"synthetic response\" };\n                        }\n                        else {\n                            // if everything is successful, we return here, otherwise an error will be thrown\n                            return [2 /*return*/, normalizer(result)];\n                        }\n                        return [3 /*break*/, 8];\n                    case 3:\n                        message = exports.DEFAULT_ERROR;\n                        _b.label = 4;\n                    case 4:\n                        _b.trys.push([4, 6, , 7]);\n                        return [4 /*yield*/, response.json()];\n                    case 5:\n                        result = (_b.sent());\n                        if (result.message)\n                            message = result.message;\n                        return [3 /*break*/, 7];\n                    case 6:\n                        _1 = _b.sent();\n                        return [3 /*break*/, 7];\n                    case 7:\n                        if (requestMap[url]) {\n                            // we got a specific error,\n                            // normally, you'd want to not fetch this again,\n                            // but the api goes down and sends 400s, so allow a refetch after errorMaxLife\n                            requestMap[url].isError = true;\n                        }\n                        // we got an error response, throw with the message in the response body json\n                        fetchError = new fetch_error_1.default(\"\" + exports.ERROR_PREFIX + message, response.status, response.statusText);\n                        _b.label = 8;\n                    case 8: return [3 /*break*/, 10];\n                    case 9:\n                        unexpectedError_1 = _b.sent();\n                        fetchError = new fetch_error_1.default(unexpectedError_1.message);\n                        // if the request fails with an unspecfied error,\n                        // the user can request again after the error timeout\n                        if (requestMap[url]) {\n                            requestMap[url].isError = true;\n                        }\n                        return [3 /*break*/, 10];\n                    case 10: throw fetchError;\n                }\n            });\n        }); };\n        requestMap[url] = { request: makeRequest(), ts: Date.now() };\n    }\n    return requestMap[url].request;\n}\nexports.default = request;\n"},"sourceMaps":{"js":{"version":3,"file":"request.js","sourceRoot":"","sources":["../src/request.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,yCAAuC;AACvC,8DAAsC;AAGzB,QAAA,YAAY,GAAG,uBAAuB,CAAA;AACtC,QAAA,aAAa,GAAG,gBAAgB,CAAA;AAE7C,IAAM,QAAQ,GAAG,UAAC,CAAM,IAAK,OAAA,CAAC,EAAD,CAAC,CAAA;AAC9B,IAAM,UAAU,GAMZ,EAAE,CAAA;AAEN,IAAM,OAAO,GAAG,KAAK,CAAA,CAAC,kCAAkC;AACxD,IAAM,YAAY,GAAG,IAAI,CAAA,CAAC,0CAA0C;AAEpE,IAAM,UAAU,GAAG;IACf,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAA;IACtB,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,OAAO,CAAC,UAAC,GAAW;QACxC,IAAM,GAAG,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,OAAO,CAAA;QAC5D,IAAI,GAAG,GAAG,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,GAAG,EAAE;YACjC,OAAO,UAAU,CAAC,GAAG,CAAC,CAAA;SACzB;IACL,CAAC,CAAC,CAAA;AACN,CAAC,CAAA;AAED,SAAS,OAAO,CAAC,GAAW,EAAE,UAAsC,EAAE,OAAwB;IAA9F,iBAgDC;IAhD6B,2BAAA,EAAA,qBAAsC;IAAE,wBAAA,EAAA,eAAwB;IAC1F,UAAU,EAAE,CAAA;IACZ,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,OAAO,EAAE;QAC7B,IAAM,WAAW,GAAG;;;;;;;wBAGK,qBAAM,KAAK,CAAC,KAAG,qBAAS,GAAG,GAAK,EAAE;gCAC/C,MAAM,EAAE,KAAK;6BAChB,CAAC,EAAA;;wBAFI,QAAQ,GAAG,SAEf;6BACE,QAAQ,CAAC,EAAE,EAAX,wBAAW;wBACK,qBAAM,QAAQ,CAAC,IAAI,EAAE,EAAA;;wBAA/B,MAAM,GAAG,CAAC,SAAqB,CAAW;wBAChD,2DAA2D;wBAC3D,IAAI,CAAC,CAAA,MAAA,MAAM,CAAC,IAAI,0CAAE,WAAW,CAAA,EAAE;4BAC3B,MAAM,EAAE,OAAO,EAAE,oBAAoB,EAAiB,CAAA;yBACzD;6BAAM;4BACH,iFAAiF;4BACjF,sBAAO,UAAU,CAAC,MAAM,CAAC,EAAA;yBAC5B;;;wBAEG,OAAO,GAAG,qBAAa,CAAA;;;;wBAGP,qBAAM,QAAQ,CAAC,IAAI,EAAE,EAAA;;wBAA/B,MAAM,GAAG,CAAC,SAAqB,CAAgB;wBACrD,IAAI,MAAM,CAAC,OAAO;4BAAE,OAAO,GAAG,MAAM,CAAC,OAAO,CAAA;;;;;;wBAEhD,IAAI,UAAU,CAAC,GAAG,CAAC,EAAE;4BACjB,2BAA2B;4BAC3B,gDAAgD;4BAChD,8EAA8E;4BAC9E,UAAU,CAAC,GAAG,CAAC,CAAC,OAAO,GAAG,IAAI,CAAA;yBACjC;wBAED,6EAA6E;wBAC7E,UAAU,GAAG,IAAI,qBAAU,CAAC,KAAG,oBAAY,GAAG,OAAS,EAAE,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,UAAU,CAAC,CAAA;;;;;wBAGlG,UAAU,GAAG,IAAI,qBAAU,CAAC,iBAAe,CAAC,OAAO,CAAC,CAAA;wBACpD,iDAAiD;wBACjD,qDAAqD;wBACrD,IAAI,UAAU,CAAC,GAAG,CAAC,EAAE;4BACjB,UAAU,CAAC,GAAG,CAAC,CAAC,OAAO,GAAG,IAAI,CAAA;yBACjC;;6BAEL,MAAM,UAAU,CAAA;;;aACnB,CAAA;QACD,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,OAAO,EAAE,WAAW,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,GAAG,EAAE,EAAE,CAAA;KAC/D;IACD,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC,OAAO,CAAA;AAClC,CAAC;AAED,kBAAe,OAAO,CAAA","sourcesContent":["import { serverUrl } from './constants'\nimport FetchError from './fetch-error'\nimport { ErrorResult, Result } from './result-types'\n\nexport const ERROR_PREFIX = `@giphy/js-fetch-api: `\nexport const DEFAULT_ERROR = 'Error fetching'\n\nconst identity = (i: any) => i\nconst requestMap: {\n    [key: string]: {\n        request: Promise<Result>\n        ts: number // timestamp\n        isError?: boolean\n    }\n} = {}\n\nconst maxLife = 60000 // clear memory cache every minute\nconst errorMaxLife = 6000 // clear error memory cache after a second\n\nconst purgeCache = () => {\n    const now = Date.now()\n    Object.keys(requestMap).forEach((key: string) => {\n        const ttl = requestMap[key].isError ? errorMaxLife : maxLife\n        if (now - requestMap[key].ts >= ttl) {\n            delete requestMap[key]\n        }\n    })\n}\n\nfunction request(url: string, normalizer: (a: any) => any = identity, noCache: boolean = false) {\n    purgeCache()\n    if (!requestMap[url] || noCache) {\n        const makeRequest = async (): Promise<Result> => {\n            let fetchError: FetchError\n            try {\n                const response = await fetch(`${serverUrl}${url}`, {\n                    method: 'get',\n                })\n                if (response.ok) {\n                    const result = (await response.json()) as Result\n                    // no response id is an indiication of a synthetic response\n                    if (!result.meta?.response_id) {\n                        throw { message: `synthetic response` } as ErrorResult\n                    } else {\n                        // if everything is successful, we return here, otherwise an error will be thrown\n                        return normalizer(result)\n                    }\n                } else {\n                    let message = DEFAULT_ERROR\n                    try {\n                        // error results have a different format than regular results\n                        const result = (await response.json()) as ErrorResult\n                        if (result.message) message = result.message\n                    } catch (_) {}\n                    if (requestMap[url]) {\n                        // we got a specific error,\n                        // normally, you'd want to not fetch this again,\n                        // but the api goes down and sends 400s, so allow a refetch after errorMaxLife\n                        requestMap[url].isError = true\n                    }\n\n                    // we got an error response, throw with the message in the response body json\n                    fetchError = new FetchError(`${ERROR_PREFIX}${message}`, response.status, response.statusText)\n                }\n            } catch (unexpectedError) {\n                fetchError = new FetchError(unexpectedError.message)\n                // if the request fails with an unspecfied error,\n                // the user can request again after the error timeout\n                if (requestMap[url]) {\n                    requestMap[url].isError = true\n                }\n            }\n            throw fetchError\n        }\n        requestMap[url] = { request: makeRequest(), ts: Date.now() }\n    }\n    return requestMap[url].request\n}\n\nexport default request\n"]}},"error":null,"hash":"de9fef508e90d09666740ac75c38927e","cacheData":{"env":{}}}