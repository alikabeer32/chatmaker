{"id":"node_modules/@giphy/js-util/dist/gif-utils.js","dependencies":[{"name":"D:\\testhub\\node_modules\\@giphy\\js-util\\dist\\gif-utils.js.map","includedInParent":true,"mtime":499162500000},{"name":"D:\\testhub\\node_modules\\@giphy\\js-util\\src\\gif-utils.ts","includedInParent":true,"mtime":499162500000},{"name":"D:\\testhub\\package.json","includedInParent":true,"mtime":1633782651602},{"name":"D:\\testhub\\node_modules\\@giphy\\js-util\\package.json","includedInParent":true,"mtime":1633781127467},{"name":"./bestfit","loc":{"line":18,"column":40},"parent":"D:\\testhub\\node_modules\\@giphy\\js-util\\dist\\gif-utils.js","resolved":"D:\\testhub\\node_modules\\@giphy\\js-util\\dist\\bestfit.js"},{"name":"./collections","loc":{"line":19,"column":28},"parent":"D:\\testhub\\node_modules\\@giphy\\js-util\\dist\\gif-utils.js","resolved":"D:\\testhub\\node_modules\\@giphy\\js-util\\dist\\collections.js"},{"name":"./webp-check","loc":{"line":20,"column":27},"parent":"D:\\testhub\\node_modules\\@giphy\\js-util\\dist\\gif-utils.js","resolved":"D:\\testhub\\node_modules\\@giphy\\js-util\\dist\\webp-check.js"}],"generated":{"js":"\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getAltText = exports.getGifWidth = exports.getGifHeight = exports.getBestRenditionUrl = exports.getBestRendition = exports.getBestVideo = exports.getSpecificRendition = void 0;\nvar bestfit_1 = __importDefault(require(\"./bestfit\"));\nvar collections_1 = require(\"./collections\");\nvar webp_check_1 = require(\"./webp-check\");\nvar getSpecificRendition = function (_a, renditionLabel, isStill, useVideo) {\n    var images = _a.images, isSticker = _a.is_sticker;\n    if (isStill === void 0) { isStill = false; }\n    if (useVideo === void 0) { useVideo = false; }\n    if (!images || !renditionLabel)\n        return '';\n    isStill = isStill && !useVideo;\n    // @ts-ignore come back to this\n    var rendition = images[\"\" + renditionLabel + (isStill ? '_still' : '')];\n    if (rendition) {\n        if (isSticker || isStill) {\n            return rendition.url;\n        }\n        var webP = webp_check_1.SUPPORTS_WEBP && rendition.webp;\n        return useVideo ? rendition.mp4 : webP || rendition.url;\n    }\n    return '';\n};\nexports.getSpecificRendition = getSpecificRendition;\nvar getBestVideo = function (video, width, height) {\n    var assets = video === null || video === void 0 ? void 0 : video.assets;\n    if (assets) {\n        assets = __assign({}, assets);\n        // @ts-ignore we don't show source according to the existing code\n        delete assets.source;\n        var filteredAssets = Object.values(assets).sort(function (a, b) { return a.width - b.width; });\n        return bestfit_1.default(filteredAssets, width, height);\n    }\n};\nexports.getBestVideo = getBestVideo;\nvar getRenditions = function (type, images, video) {\n    return type === 'video' && video && video.previews && !Object.keys(images).length ? video.previews : images;\n};\nvar getBestRendition = function (images, gifWidth, gifHeight, scaleUpMaxPixels) {\n    var checkRenditions = collections_1.pick(images, [\n        'original',\n        'fixed_width',\n        'fixed_height',\n        'fixed_width_small',\n        'fixed_height_small',\n    ]);\n    var testImages = Object.entries(checkRenditions).map(function (_a) {\n        var renditionName = _a[0], val = _a[1];\n        return (__assign({ renditionName: renditionName }, val));\n    });\n    return bestfit_1.default(testImages, gifWidth, gifHeight, scaleUpMaxPixels);\n};\nexports.getBestRendition = getBestRendition;\nvar getBestRenditionUrl = function (_a, gifWidth, gifHeight, options) {\n    var images = _a.images, video = _a.video, type = _a.type;\n    if (options === void 0) { options = { isStill: false, useVideo: false }; }\n    if (!gifWidth || !gifHeight || !images)\n        return '';\n    var useVideo = options.useVideo, isStill = options.isStill, scaleUpMaxPixels = options.scaleUpMaxPixels;\n    var renditions = getRenditions(type, images, video);\n    var renditionName = exports.getBestRendition(renditions, gifWidth, gifHeight, scaleUpMaxPixels).renditionName;\n    // still, video, webp or gif\n    var key = \"\" + renditionName + (isStill && !useVideo ? '_still' : '');\n    var rendition = renditions[key];\n    var match = useVideo ? rendition.mp4 : webp_check_1.SUPPORTS_WEBP && rendition.webp ? rendition.webp : rendition.url;\n    return (match || '');\n};\nexports.getBestRenditionUrl = getBestRenditionUrl;\nvar getGifHeight = function (_a, gifWidth) {\n    var images = _a.images;\n    var fixed_width = images.fixed_width;\n    if (fixed_width) {\n        var width = fixed_width.width, height = fixed_width.height;\n        var aspectRatio = width / height;\n        return Math.round(gifWidth / aspectRatio);\n    }\n    return 0;\n};\nexports.getGifHeight = getGifHeight;\nvar getGifWidth = function (_a, gifHeight) {\n    var images = _a.images;\n    var fixed_width = images.fixed_width;\n    if (fixed_width) {\n        var width = fixed_width.width, height = fixed_width.height;\n        var aspectRatio = width / height;\n        return Math.round(gifHeight * aspectRatio);\n    }\n    return 0;\n};\nexports.getGifWidth = getGifWidth;\n/**\n * GIF Text - Alt Text: Generates alt text for\n * GIF images based on username and tags.\n * @prop  {Gif}\n * @return {String} GIF alt text.\n */\nvar getAltText = function (_a) {\n    var user = _a.user, _b = _a.tags, tags = _b === void 0 ? [] : _b, _c = _a.is_sticker, is_sticker = _c === void 0 ? false : _c, _d = _a.title, title = _d === void 0 ? '' : _d;\n    if (title) {\n        return title;\n    }\n    var username = (user && user.username) || '';\n    var filteredTags = collections_1.take(collections_1.without(tags, ['transparent']), username ? 4 : 5);\n    return \"\" + (username ? username + \" \" : \"\") + filteredTags.join(' ') + \" \" + (is_sticker ? 'Sticker' : 'GIF');\n};\nexports.getAltText = getAltText;\n"},"sourceMaps":{"js":{"version":3,"file":"gif-utils.js","sourceRoot":"","sources":["../src/gif-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { IGif, IImage, IImages, ImageAllTypes, IRendition } from '@giphy/js-types'\nimport IVideo from '@giphy/js-types/dist/video'\nimport bestfit from './bestfit'\nimport { pick, take, without } from './collections'\nimport { SUPPORTS_WEBP } from './webp-check'\n\nexport const getSpecificRendition = (\n    { images, is_sticker: isSticker }: IGif,\n    renditionLabel: string,\n    isStill = false,\n    useVideo = false\n) => {\n    if (!images || !renditionLabel) return ''\n    isStill = isStill && !useVideo\n    // @ts-ignore come back to this\n    const rendition = images[`${renditionLabel}${isStill ? '_still' : ''}`] as ImageAllTypes\n\n    if (rendition) {\n        if (isSticker || isStill) {\n            return rendition.url\n        }\n        const webP = SUPPORTS_WEBP && rendition.webp\n        return useVideo ? rendition.mp4 : webP || rendition.url\n    }\n\n    return ''\n}\n\ninterface IRenditionWithName extends IRendition {\n    renditionName: keyof IImages\n}\n\nexport const getBestVideo = (video: IGif['video'], width: number, height: number) => {\n    let assets = video?.assets\n    if (assets) {\n        assets = { ...assets }\n        // @ts-ignore we don't show source according to the existing code\n        delete assets.source\n        const filteredAssets = Object.values(assets).sort((a: IRendition, b: IRendition) => a.width - b.width)\n        return bestfit(filteredAssets, width, height) as IImage\n    }\n}\n\nconst getRenditions = (type: IGif['type'], images: IImages, video?: IVideo) =>\n    type === 'video' && video && video.previews && !Object.keys(images).length ? video.previews : images\n\nexport const getBestRendition = (\n    images: IImages,\n    gifWidth: number,\n    gifHeight: number,\n    scaleUpMaxPixels?: number\n): IRenditionWithName => {\n    const checkRenditions = pick(images, [\n        'original',\n        'fixed_width',\n        'fixed_height',\n        'fixed_width_small',\n        'fixed_height_small',\n    ])\n    const testImages = Object.entries(checkRenditions).map(([renditionName, val]) => ({\n        renditionName,\n        ...val,\n    })) as IRenditionWithName[]\n    return bestfit(testImages, gifWidth, gifHeight, scaleUpMaxPixels) as IRenditionWithName\n}\n\ntype Options = {\n    isStill?: boolean\n    useVideo?: boolean\n    scaleUpMaxPixels?: number\n}\nexport const getBestRenditionUrl = (\n    { images, video, type }: IGif,\n    gifWidth: number,\n    gifHeight: number,\n    options: Options = { isStill: false, useVideo: false }\n): keyof IImages | '' => {\n    if (!gifWidth || !gifHeight || !images) return ''\n    const { useVideo, isStill, scaleUpMaxPixels } = options\n    const renditions = getRenditions(type, images, video)\n    const { renditionName } = getBestRendition(renditions, gifWidth, gifHeight, scaleUpMaxPixels)\n\n    // still, video, webp or gif\n    const key = `${renditionName}${isStill && !useVideo ? '_still' : ''}` as keyof IImages\n    const rendition = renditions[key] as ImageAllTypes\n\n    const match = useVideo ? rendition.mp4 : SUPPORTS_WEBP && rendition.webp ? rendition.webp : rendition.url\n    return (match || '') as keyof IImages\n}\n\nexport const getGifHeight = ({ images }: IGif, gifWidth: number) => {\n    const { fixed_width } = images\n    if (fixed_width) {\n        const { width, height } = fixed_width\n        const aspectRatio = width / height\n        return Math.round(gifWidth / aspectRatio)\n    }\n    return 0\n}\n\nexport const getGifWidth = ({ images }: IGif, gifHeight: number) => {\n    const { fixed_width } = images\n    if (fixed_width) {\n        const { width, height } = fixed_width\n        const aspectRatio = width / height\n        return Math.round(gifHeight * aspectRatio)\n    }\n    return 0\n}\n\n/**\n * GIF Text - Alt Text: Generates alt text for\n * GIF images based on username and tags.\n * @prop  {Gif}\n * @return {String} GIF alt text.\n */\nexport const getAltText = ({ user, tags = [], is_sticker = false, title = '' }: IGif): string => {\n    if (title) {\n        return title\n    }\n    const username = (user && user.username) || ''\n    const filteredTags = take(without(tags, ['transparent']), username ? 4 : 5)\n    return `${username ? `${username} ` : ``}${filteredTags.join(' ')} ${is_sticker ? 'Sticker' : 'GIF'}`\n}\n"]}},"error":null,"hash":"e63495ee43d48dbd50e39cd06365b3f5","cacheData":{"env":{}}}